require 'json'
require 'active_record'
require 'sqlite3'
require 'logger'

# Prevent ActiveRecord from printing to stdout
ActiveRecord::Base.logger = Logger.new(IO::NULL)

# In-memory database setup
ActiveRecord::Base.establish_connection(adapter: 'sqlite3', database: ':memory:')

# Schema definition
ActiveRecord::Schema.define do
  create_table :accounts do |t|
    t.integer :user_id
    t.integer :assigned_to
    t.string :name, limit: 64, default: "", null: false
    t.string :access, limit: 8, default: "Public"
    t.string :website, limit: 64
    t.string :toll_free_phone, limit: 32
    t.string :phone, limit: 32
    t.string :fax, limit: 32
    t.datetime :deleted_at
    t.datetime :created_at
    t.datetime :updated_at
    t.string :email, limit: 64
    t.string :background_info, limit: 255
    t.integer :rating, default: 0, null: false
    t.string :category, limit: 32
    # Add fake columns for geo-validation and the broken :location method
    t.decimal :latitude
    t.decimal :longitude
    t.text :billing_address # For Account#location method which uses self[:billing_address]
    t.text :subscribed_users
  end

  create_table :users do |t|
    t.string :name
  end

  create_table :addresses do |t|
    t.string :address_type
    t.integer :addressable_id
    t.string :addressable_type
    t.string :street1
    t.string :city
  end

  create_table :contacts do |t|; end
  create_table :opportunities do |t|
    t.string :stage
  end
  create_table :tasks do |t|
    t.integer :asset_id
    t.string :asset_type
  end
  create_table :emails do |t|; end
  create_table :versions do |t|; end
  create_table :tags do |t|; end
  create_table :taggings do |t|; end
  create_table :comments do |t|; end
  create_table :fields do |t|; end

  create_table :account_contacts, id: false do |t|
    t.integer :account_id
    t.integer :contact_id
  end

  create_table :account_opportunities, id: false do |t|
    t.integer :account_id
    t.integer :opportunity_id
  end

  create_table :permissions do |t|
    t.integer :user_id
    t.integer :asset_id
    t.string :asset_type
  end
end

# --- Mocked Dependencies ---

# Mock for global Settings object
class Setting
  def self.unroll(key)
    if key == :account_category
      [['Customer', 'Customer'], ['Partner', 'Partner'], ['Vendor', 'Vendor']]
    else
      []
    end
  end

  @require_unique_account_names = false
  def self.require_unique_account_names; @require_unique_account_names; end
  def self.require_unique_account_names=(val); @require_unique_account_names = val; end
end

# Mock methods for gems and concerns that are called at class-load time.
class ActiveRecord::Base
  def self.uses_user_permissions; end
  def self.acts_as_commentable; end
  def self.uses_comment_extensions; end
  def self.acts_as_taggable_on(*); end
  def self.has_paper_trail(*); end
  def self.has_fields; end
  def self.exportable; end
  def self.sortable(*); end
  def self.has_ransackable_associations(*); end
  def self.ransack_can_autocomplete; end
end

# --- Dependent Models ---
class User < ActiveRecord::Base; end
class Address < ActiveRecord::Base
  belongs_to :addressable, polymorphic: true
  def self.reject_address(attributes)
    attributes.all? { |key, value| ['_destroy', 'id', 'address_type'].include?(key) || value.blank? }
  end
end
class Contact < ActiveRecord::Base; end
class Opportunity < ActiveRecord::Base
  scope :pipeline, -> { where(stage: 'pipeline') }
end
class Task < ActiveRecord::Base; end
class Email < ActiveRecord::Base; end
class Version < ActiveRecord::Base; end
class AccountContact < ActiveRecord::Base
  belongs_to :account
  belongs_to :contact
end
class AccountOpportunity < ActiveRecord::Base
  belongs_to :account
  belongs_to :opportunity
end
class Permission < ActiveRecord::Base; end

# --- Source Code ---
# The class to be tested, with necessary mocks for missing methods/concerns.
# frozen_string_literal: true
class Account < ActiveRecord::Base
  # Self-mocking for missing concern/gem methods
  def permissions
    Permission.where(asset_id: id, asset_type: 'Account')
  end

  def save_with_model_permissions(model)
    # Mock implementation of a method from a missing concern
    self.user_id = model.user_id if model.respond_to?(:user_id)
    save
  end

  def self.ransack(params = {})
    query = params['name_or_email_cont']
    result_set = if query
                   where("name LIKE ? OR email LIKE ?", "%#{query}%", "%#{query}%")
                 else
                   all
                 end
    # Mock the Ransack::Search object's 'result' method
    def result_set.result; self; end
    result_set
  end

  # Copied source
  belongs_to :user, optional: true # TODO: Is this really optional?
  belongs_to :assignee, class_name: "User", foreign_key: :assigned_to, optional: true
  has_many :account_contacts, dependent: :destroy
  has_many :contacts, -> { distinct }, through: :account_contacts
  has_many :account_opportunities, dependent: :destroy
  has_many :opportunities, -> { order("opportunities.id DESC").distinct }, through: :account_opportunities
  has_many :pipeline_opportunities, -> { order("opportunities.id DESC").distinct.pipeline }, through: :account_opportunities, source: :opportunity
  has_many :tasks, as: :asset, dependent: :destroy # , :order => 'created_at DESC'
  has_one :billing_address, -> { where(address_type: "Billing") }, dependent: :destroy, as: :addressable, class_name: "Address"
  has_one :shipping_address, -> { where(address_type: "Shipping") }, dependent: :destroy, as: :addressable, class_name: "Address"
  has_many :addresses, dependent: :destroy, as: :addressable, class_name: "Address" # advanced search uses this
  has_many :emails, as: :mediator

  serialize :subscribed_users, type: Array

  accepts_nested_attributes_for :billing_address,  allow_destroy: true, reject_if: proc { |attributes| Address.reject_address(attributes) }
  accepts_nested_attributes_for :shipping_address, allow_destroy: true, reject_if: proc { |attributes| Address.reject_address(attributes) }

  scope :state, lambda { |filters|
    where('category IN (?)' + (filters.delete('other') ? ' OR category IS NULL' : ''), filters)
  }
  scope :created_by,  ->(user) { where(user_id: user.id) }
  scope :assigned_to, ->(user) { where(assigned_to: user.id) }

  scope :text_search, ->(query) { ransack('name_or_email_cont' => query).result }

  scope :visible_on_dashboard, lambda { |user|
    # Show accounts which either belong to the user and are unassigned, or are assigned to the user
    where('(user_id = :user_id AND assigned_to IS NULL) OR assigned_to = :user_id', user_id: user.id)
  }

  scope :by_name, -> { order(:name) }

  uses_user_permissions
  acts_as_commentable
  uses_comment_extensions
  acts_as_taggable_on :tags
  has_paper_trail versions: { class_name: 'Version' }, ignore: [:subscribed_users]
  has_fields
  exportable
  sortable by: ["name ASC", "rating DESC", "created_at DESC", "updated_at DESC"], default: "created_at DESC"

  has_ransackable_associations %w[contacts opportunities tags activities emails addresses comments tasks]
  ransack_can_autocomplete

  validates_presence_of :name, message: :missing_account_name
  validates_uniqueness_of :name, scope: :deleted_at, if: -> { Setting.require_unique_account_names }
  validates :rating, inclusion: { in: 0..5 }, allow_blank: true
  validates :category, inclusion: { in: proc { Setting.unroll(:account_category).map { |s| s.last.to_s } } }, allow_blank: true
  validates :latitude, numericality: { greater_than_or_equal_to: -90, less_than_or_equal_to: 90, allow_blank: true }
  validates :longitude, numericality: { greater_than_or_equal_to: -180, less_than_or_equal_to: 180, allow_blank: true }
  validate :users_for_shared_access

  before_save :nullify_blank_category

  # Default values provided through class methods.
  #----------------------------------------------------------------------------
  def self.per_page
    20
  end

  # Extract last line of billing address and get rid of numeric zipcode.
  #----------------------------------------------------------------------------
  def location
    return "" unless self[:billing_address]

    location = self[:billing_address].strip.split("\n").last
    location&.gsub(/(^|\s+)\d+(:?\s+|$)/, " ")&.strip
  end

  # Attach given attachment to the account if it hasn't been attached already.
  #----------------------------------------------------------------------------
  def attach!(attachment)
    send(attachment.class.name.tableize) << attachment unless send("#{attachment.class.name.downcase}_ids").include?(attachment.id)
  end

  # Discard given attachment from the account.
  #----------------------------------------------------------------------------
  def discard!(attachment)
    if attachment.is_a?(Task)
      attachment.update_attribute(:asset, nil)
    else # Contacts, Opportunities
      send(attachment.class.name.tableize).delete(attachment)
    end
  end

  # Class methods.
  #----------------------------------------------------------------------------
  def self.create_or_select_for(model, params)
    # Attempt to find existing account
    return Account.find(params[:id]) if params[:id].present?

    if params[:name].present?
      account = Account.find_by(name: params[:name])
      return account if account
    end

    # Fallback to create new account
    params[:user] = model.user if model
    account = Account.new(params)
    if account.access != "Lead" || model.nil?
      account.save
    else
      account.save_with_model_permissions(model)
    end
    account
  end

  private

  # Make sure at least one user has been selected if the account is being shared.
  #----------------------------------------------------------------------------
  def users_for_shared_access
    errors.add(:access, :share_account) if self[:access] == "Shared" && permissions.none?
  end

  def nullify_blank_category
    self.category = nil if category.blank?
  end

  ActiveSupport.run_load_hooks(:fat_free_crm_account, self) if self.respond_to?(:run_load_hooks)
end

# --- Characterization Tests ---

results = {}

def run_test(key, &block)
  ActiveRecord::Base.transaction do
    yield
  ensure
    raise ActiveRecord::Rollback
  end
rescue => e
  @results[key] = { error: e.class.name, message: e.message, backtrace: e.backtrace.first(5) }
end

run_test 'characterization' do
  # --- Setup test data ---
  user1 = User.create!(name: 'User 1')
  user2 = User.create!(name: 'User 2')
  contact1 = Contact.create!
  contact2 = Contact.create!
  op1 = Opportunity.create!(stage: 'pipeline')
  op2 = Opportunity.create!
  task1 = Task.create!

  # --- Class Methods ---
  results['Account_per_page_default'] = Account.per_page

  # Account.create_or_select_for
  acc_for_select = Account.create!(name: 'Existing Co', user: user1)
  results['Account_create_or_select_for_by_id'] = Account.create_or_select_for(nil, { id: acc_for_select.id }).id == acc_for_select.id
  results['Account_create_or_select_for_by_name'] = Account.create_or_select_for(nil, { name: 'Existing Co' }).id == acc_for_select.id
  new_acc = Account.create_or_select_for(nil, { name: 'New Co', user: user1 })
  results['Account_create_or_select_for_create_new'] = { name: new_acc.name, persisted: new_acc.persisted? }
  lead_acc = Account.create_or_select_for(user1, { name: 'Lead Co', access: 'Lead' })
  results['Account_create_or_select_for_create_lead'] = { name: lead_acc.name, persisted: lead_acc.persisted?, user_id: lead_acc.user_id }

  # --- Instance Methods ---
  acc_location = Account.new(name: 'Location Test')
  results['Account_location_nil'] = acc_location.location
  acc_location.billing_address = "123 Main St\nAnytown, USA 12345"
  results['Account_location_with_zip'] = acc_location.location
  acc_location.billing_address = "Another Place\nBig City"
  results['Account_location_no_zip'] = acc_location.location

  acc_attach = Account.create!(name: 'Attach Test')
  acc_attach.attach!(contact1)
  results['Account_attach_new_contact'] = acc_attach.contacts.count
  acc_attach.attach!(contact1)
  results['Account_attach_existing_contact'] = acc_attach.contacts.count
  acc_attach.attach!(op1)
  results['Account_attach_opportunity'] = acc_attach.opportunities.count
  
  acc_discard = Account.create!(name: 'Discard Test')
  acc_discard.contacts << contact2
  acc_discard.tasks << task1
  results['Account_discard_counts_before'] = { contacts: acc_discard.contacts.count, tasks: acc_discard.tasks.count }
  acc_discard.discard!(contact2)
  acc_discard.discard!(task1)
  task1.reload
  results['Account_discard_counts_after'] = { contacts: acc_discard.contacts.count, tasks: acc_discard.tasks.count, task_asset_nil: task1.asset_id.nil? }


  # --- Validations ---
  a = Account.new; a.valid?; results['Account_validation_blank'] = a.errors.to_hash
  a = Account.new(name: 'Valid Name', rating: 99); a.valid?; results['Account_validation_rating_too_high'] = a.errors.to_hash
  a = Account.new(name: 'Valid Name', rating: -1); a.valid?; results['Account_validation_rating_too_low'] = a.errors.to_hash
  a = Account.new(name: 'Valid Name', rating: 3); a.valid?; results['Account_validation_rating_valid'] = a.errors.to_hash
  a = Account.new(name: 'Valid Name', category: 'Alien'); a.valid?; results['Account_validation_category_invalid'] = a.errors.to_hash
  a = Account.new(name: 'Valid Name', category: 'Customer'); a.valid?; results['Account_validation_category_valid'] = a.errors.to_hash
  a = Account.new(name: 'Valid Name', access: 'Shared'); a.valid?; results['Account_validation_shared_no_users'] = a.errors.to_hash
  shared_acc = Account.create!(name: 'Shared Account', access: 'Shared')
  Permission.create!(asset: shared_acc, user: user1)
  shared_acc.valid?; results['Account_validation_shared_with_user'] = shared_acc.errors.to_hash
  a = Account.new(name: 'Geo', latitude: 91); a.valid?; results['Account_validation_latitude_high'] = a.errors.to_hash
  a = Account.new(name: 'Geo', longitude: -181); a.valid?; results['Account_validation_longitude_low'] = a.errors.to_hash

  # Uniqueness validation
  Account.create!(name: 'Unique Test')
  Setting.require_unique_account_names = true
  a = Account.new(name: 'Unique Test'); a.valid?; results['Account_validation_uniqueness_on'] = a.errors.to_hash
  Setting.require_unique_account_names = false
  a = Account.new(name: 'Unique Test'); a.valid?; results['Account_validation_uniqueness_off'] = a.errors.to_hash

  # --- Callbacks ---
  acc_callback = Account.create!(name: 'Callback Test', category: '')
  results['Account_callback_nullify_blank_category'] = acc_callback.reload.category

  # --- Nested Attributes ---
  acc_nested = Account.create(name: 'Nested Test', billing_address_attributes: { street1: '1 Main St', city: 'Billington' })
  results['Account_nested_attributes_create_billing'] = { created: acc_nested.persisted?, address_city: acc_nested.billing_address.city }
  acc_nested.update(shipping_address_attributes: { street1: '', city: ''})
  results['Account_nested_attributes_reject_blank'] = acc_nested.shipping_address.nil?

  # --- Scopes ---
  Account.destroy_all
  s_acc1 = Account.create!(name: 'C corp', user: user1, category: 'Customer', created_at: 2.days.ago)
  s_acc2 = Account.create!(name: 'A inc', user: user1, assigned_to: user1, category: 'Partner', created_at: 1.day.ago)
  s_acc3 = Account.create!(name: 'B llc', user: user2, assigned_to: user1, category: 'Customer', email: 'contact@b.com')
  s_acc4 = Account.create!(name: 'D co', user: user2, assigned_to: user2, category: nil)
  
  results['Account_scope_state_single'] = Account.state(['Customer']).pluck(:id).sort
  results['Account_scope_state_multiple'] = Account.state(['Customer', 'Partner']).pluck(:id).sort
  results['Account_scope_state_with_other'] = Account.state(['Customer', 'other']).pluck(:id).sort
  results['Account_scope_created_by_user1'] = Account.created_by(user1).pluck(:id).sort
  results['Account_scope_assigned_to_user1'] = Account.assigned_to(user1).pluck(:id).sort
  results['Account_scope_text_search_name'] = Account.text_search('inc').pluck(:id).sort
  results['Account_scope_text_search_email'] = Account.text_search('contact@b.com').pluck(:id).sort
  results['Account_scope_visible_on_dashboard_user1'] = Account.visible_on_dashboard(user1).pluck(:id).sort
  results['Account_scope_visible_on_dashboard_user2'] = Account.visible_on_dashboard(user2).pluck(:id).sort
  results['Account_scope_by_name'] = Account.by_name.pluck(:name)

  # --- Associations ---
  assoc_acc = Account.create!(name: "Assoc Test")
  assoc_acc.contacts << contact1
  assoc_acc.opportunities << op1
  assoc_acc.opportunities << op2
  
  results['Account_assoc_pipeline_opportunities'] = assoc_acc.pipeline_opportunities.pluck(:id)
end

puts JSON.dump(results)