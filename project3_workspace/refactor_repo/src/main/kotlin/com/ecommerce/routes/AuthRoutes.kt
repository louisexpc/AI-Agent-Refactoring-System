
package com.ecommerce.routes

import com.ecommerce.models.User
import com.ecommerce.models.UserRegistration
import com.ecommerce.models.UserRole
import com.ecommerce.plugins.generateToken
import com.ecommerce.repository.UserRepository
import io.ktor.http.* 
import io.ktor.server.application.*
import io.ktor.server.request.*
import io.ktor.server.response.* 
import io.ktor.server.routing.*
import org.mindrot.jbcrypt.BCrypt

fun Route.authRoutes(userRepository: UserRepository, secret: String, issuer: String, audience: String) {

    post("/register") {
        val userRegistration = call.receive<UserRegistration>()

        if (userRepository.findByEmail(userRegistration.email) != null) {
            call.respond(HttpStatusCode.Conflict, "User already exists")
            return@post
        }

        val hashedPassword = BCrypt.hashpw(userRegistration.password, BCrypt.gensalt())
        val user = User(
            id = 0, // ID will be generated by the database
            firstName = userRegistration.firstName,
            lastName = userRegistration.lastName,
            email = userRegistration.email,
            mobile = userRegistration.mobile,
            password = hashedPassword,
            role = UserRole.USER
        )

        val createdUser = userRepository.createUser(user)
        call.respond(HttpStatusCode.Created, createdUser)
    }

    post("/login") {
        val credentials = call.receive<UserRegistration>()
        val user = userRepository.findByEmail(credentials.email)

        if (user == null || !BCrypt.checkpw(credentials.password, user.password)) {
            call.respond(HttpStatusCode.Unauthorized, "Invalid credentials")
            return@post
        }

        val token = generateToken(user, secret, issuer, audience)
        call.respond(HttpStatusCode.OK, mapOf("token" to token))
    }
}
